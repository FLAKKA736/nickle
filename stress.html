<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Strobing Wireframe Boxes</title>
  <style>
    body, html {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Three.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

  <script>
    // === SETTINGS ===
    const BOX_COUNT = 25;         // Number of boxes per axis
    const BOX_SPACING = 0.02;       // Spacing between boxes
    const STROBE_INTERVAL = 100; // Time in ms between color changes

    // === THREE.JS SETUP ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === BOX CREATION ===
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const boxes = [];

    for (let x = 0; x < BOX_COUNT; x++) {
      for (let y = 0; y < BOX_COUNT; y++) {
        for (let z = 0; z < BOX_COUNT; z++) {
          const material = new THREE.MeshBasicMaterial({
            color: getRandomColor(),
            wireframe: true
          });

          const cube = new THREE.Mesh(geometry, material);
          cube.position.set(
            (x - BOX_COUNT / 2) * BOX_SPACING,
            (y - BOX_COUNT / 2) * BOX_SPACING,
            (z - BOX_COUNT / 2) * BOX_SPACING
          );
          scene.add(cube);
          boxes.push(cube);
        }
      }
    }

    // === CAMERA SETUP ===
    const distance = BOX_COUNT * BOX_SPACING * 1.5;
    camera.position.set(distance, distance, distance);
    camera.lookAt(0, 0, 0);

    // === COLOR STROBE FUNCTION ===
    function getRandomColor() {
      return Math.random() * 0xffffff;
    }

    function strobeColors() {
      boxes.forEach(box => {
        box.material.color.set(getRandomColor());
      });
      renderer.render(scene, camera);
    }

    // === INITIAL RENDER + STROBE LOOP ===
    renderer.render(scene, camera);
    setInterval(strobeColors, STROBE_INTERVAL);

    // === HANDLE WINDOW RESIZE ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
